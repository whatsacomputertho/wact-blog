
<p>With &#8203;our &#8203;model &#8203;trained and application written, our final task will be to deploy our application.&#160; As with the rest of the project, I wanted to approach this phase of the deployment with both simplicity and long-term scalability in mind.&#160; The deployment process should be semi-automated and repeatable both locally and on remote machines.&#160; It should be possible to deploy the FBSim application on a generic linux VM, and on a Kubernetes cluster.</p>
<p>As such, the obvious choice would be to containerize the FBSim application, and to develop both a docker-compose-based deployment, and a Kubernetes-based deployment.&#160; To support these deployments and satisfy the "semi-automated" requirement, I would need to develop CI to regularly build my container images.<br></p>
<h2 data-original-level="H2" id="header-694c2fe0-5c44-9ccd-289a-c76a9f6452f7">Continuous &#8203;Integration</h2>
<p>I developed CI applied to both the fbsim-ui and fbsim-api repositories.&#160; Across both repositories, the CI followed a very similar pattern.</p>
<ol><li role="textbox">Write a Containerfile that builds ​the ​application ​and/or copies the application into the image<br></li><li role="textbox">Write a GitHub actions workflow that runs the containerized build and pushes the built image to ghcr.io</li><li role="textbox">Use the repository's package manifest (cargo.toml, package.json) to version &amp; tag the images in ghcr.io<br></li></ol>
<h3 data-original-level="H3" id="header-afd4f595-af5a-075b-ff0e-499c87048aed">Containerization<br></h3>
<p>For the fbsim-ui, the containerization process was quite simple.&#160; Since JavaScript is an interpreted language, I would just need to make sure that I use a base image with NodeJS built in, then copy my source code and static content directly into the image in its expected directory structure.</p>
<code-sample type="yaml" copy-clipboard-button><template preserve-content="preserve-content"># Copy files into builder image for single-layer copy into main image
FROM scratch AS copyfiles
COPY src/*.js /copyfiles/src/
COPY static/css/*.css /copyfiles/static/css/
COPY static/img/*.png /copyfiles/static/img/
COPY static/img/*.jpg /copyfiles/static/img/
COPY static/js/*.js /copyfiles/static/js/
COPY static/views/*.hbs /copyfiles/static/views/
COPY package.json package-lock.json LICENSE /copyfiles/

# Main image build
FROM node:20-bookworm
COPY --from=copyfiles /copyfiles/ /opt/fbsim-ui/
WORKDIR /opt/fbsim-ui
RUN npm install
CMD ["npm", "run", "prod"]</template></code-sample>
<p>For the fbsim-api, the containerization process was slightly more complicated due to the fact that compiling an API built with the Rocket framework involves dynamic linking.&#160; To overcome this challenge I followed <a href="https://rocket.rs/guide/v0.5/deploying/#containerization" target="_blank">the official Rocket containerization guide</a> which uses GNU <code>objcopy</code> to combine all dynamically linked libraries together into the main API server executable.<br></p>
<h3 data-original-level="H3" id="header-8d51747e-43ad-e4c2-c88b-90c4dc4c279a">GitHub Actions CI<br></h3>
<p>While the above Containerfiles can be built locally, it is more typical to develop a continuous integration (CI) process that regularly builds the application images when new code is contributed.&#160; GitHub Actions provides this mechanism directly built into the GitHub platform, and I found it to be very reliable and useful for containerized application development on public GitHub.</p>
<p>GitHub Actions workflows are placed in the .github/workflows subdirectory of the repository.&#160; The workflows are defined by YAML specifications which defines properties of the workflow such as</p>
<ol><li role="textbox">The ​steps ​of the workflow</li><li role="textbox">The ​script ​executed ​during ​each ​step ​of ​the ​workflow</li><li role="textbox">Which ​events ​trigger ​the ​workflow</li></ol>
<p>and more.&#160; My workflows for the fbsim-ui and fbsim-api are very simple, they first extract the package version from the package manifest; this is later used to tag the image.&#160; They then build the image, and push the image into ghcr.io, GitHub's built-in container image registry.&#160; Below is the full GitHub actions workflow for the fbsim-api at the time of writing this blog.</p>
<code-sample type="yaml" copy-clipboard-button><template preserve-content="preserve-content">name: FBSim API build
on:
  push:
    branches: [ "main" ]
jobs:
  build:
    permissions: write-all
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - name: Build and push the FBSim API image
      run: |
        # Get the package version from cargo.toml
        echo "[INFO] Getting rust package version from cargo.toml"
        RUST_PACKAGE_VERSION=$(
          awk -F ' = ' '$1 ~ /version/ { gsub(/[\"]/, "", $2); printf("%s",$2) }' Cargo.toml
        );
        echo "[DEBU] Package version: ${RUST_PACKAGE_VERSION}"
        
        # Build the FBSim API image
        echo "[INFO] Building and pushing ghcr.io/whatsacomputertho/fbsim-api:v${RUST_PACKAGE_VERSION}"
        docker login \
          -u whatsacomputertho \
          -p ${{ secrets.GITHUB_TOKEN }} \
          ghcr.io/whatsacomputertho
        docker build . \
          -f Containerfile \
          --tag ghcr.io/whatsacomputertho/fbsim-api:v${RUST_PACKAGE_VERSION}
        docker push \
          ghcr.io/whatsacomputertho/fbsim-api:v${RUST_PACKAGE_VERSION}</template></code-sample>
<h3 data-original-level="H3" id="header-1e88bc0c-4aad-4d70-84da-b3aafd70090e">GitHub Container Registry<br></h3>
<p>The GitHub container image registry, ghcr.io (also sometimes called "GitHub Packages") is used in the above example to publish the images built in my GitHub Actions workflows.&#160; In order to publish the images, a GitHub token with the proper permissions must be used.&#160; Conveniently, GitHub actions automatically generates a short-lived token on each run that can be used to publish my images, as seen above when I reference <code>${{ secrets.GITHUB_TOKEN }}</code>.</p>
<p>The &#8203;GitHub &#8203;container &#8203;image &#8203;registry &#8203;is &#8203;publicly &#8203;readable, &#8203;meaning &#8203;that &#8203;anyone &#8203;can pull the container images built and published by my workflows.&#160; So you, reading this at home, can deploy FBSim using the exact same image references as I use for my deployment - we will both pull the images from ghcr.io.<br></p>
<h2 data-original-level="H2" id="header-2a0e0370-3025-9626-8d5c-143633e3c2cd">Deployment</h2>
<p>Briefly describe the requirements for deploying FBSim</p>
<h3 data-original-level="H3" id="header-19182742-e79f-92da-38d3-4255fdad79c0">&#8203;Compose</h3>
<p>Describe &#8203;the &#8203;docker &#8203;compose &#8203;deployment &#8203;process for FBSim<br></p>
<h3 data-original-level="H3" id="header-0dcd74b5-ca39-679e-33f0-e8703788b862">Kubernetes<br></h3>
<p>Describe the Kubernetes deployment process for FBSim<br></p>
