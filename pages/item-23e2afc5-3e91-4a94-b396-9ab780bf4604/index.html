
<p>Understanding and modeling the real-world football data will only get us so far.&#160; Now we need to architect an application around our model.&#160; In this blog, I will walk through the architecture of the full-stack web application I developed around my football box score generator model.</p>
<h2 data-original-level="H2" id="header-0a8b44dc-f7ec-9b8b-031b-f36901d07660">Architecture<br></h2>
<p>The application consists of &#8203;the &#8203;following &#8203;components &#8203;at &#8203;a &#8203;high &#8203;level</p>
<ul><li role="textbox">A ​Rust ​crate (<a href="https://github.com/whatsacomputertho/fbsim-core" target="_blank">fbsim-core</a>) containing the core structures and functions for running football simulations. ​ ​It ​is ​<a href="https://crates.io/crates/fbsim-core" target="_blank">published ​on ​crates.io</a>, ​with <a href="https://docs.rs/fbsim-core/1.0.0-alpha.3/fbsim_core/" target="_blank">​public documentation on doc.rs</a><br></li><li role="textbox">A ​Rust ​CLI ​(<a href="https://github.com/whatsacomputertho/fbsim-cli" target="_blank">fbsim-cli</a>) wrapping the core library and providing a quick and easy interface for running football simulations on the command-line</li><li role="textbox">A ​Rust ​​API ​(<a href="https://github.com/whatsacomputertho/fbsim-api" target="_blank">fbsim-api</a>) packaging the core library as a REST API and making it available to HTTP clients</li><li role="textbox">A ​vanilla web UI (<a href="https://github.com/whatsacomputertho/fbsim-ui" target="_blank">fbsim-ui</a>) composed of VanillaJS, W3C-standard web components which leverage the FBSim API as a back-end</li></ul>
<p>In addition, the API and UI are containerized for deployment on a VM 
using docker-compose, and for deployment on a Kubernetes-based container
 orchestration platform.&#160; CI was implemented for each containerized 
service using GitHub actions, and the container images are stored on 
GitHub's <a href="https://github.com/features/actions" target="_blank">ghcr.io</a> image registry.</p>
<div><br></div>
<media-image source="files/fbsim-architecture.png" card accent-color="grey" size="wide" offset="none" citation="FBSim architecture diagram"></media-image>
<h2 data-original-level="H2" id="header-6e41b55e-79c9-107b-0a69-659da51fbe42">Implementation</h2>
<p>The key technologies used for this initial implementation of FBSim, and the role they played in the implementation, will be discussed in the following sections.<br></p>
<h3 data-original-level="H3" id="header-5f0f5fd4-0080-e17a-97de-ce0ff16250d4">Rust Crate<br></h3>
<p>A crate is the Rust language's module system.&#160; In most cases, the term crate is synonymous with the term library, module, or package.&#160; The Rust foundation hosts <a href="https://crates.io/" target="_blank">crates.io</a>, which is the Rust language's public-facing package server.&#160; One can think of this platform as synonymous to Python's PyPi and JavaScript's NPM.</p>
<p>The main library underlying FBSim is called <a href="https://github.com/whatsacomputertho/fbsim-core" target="_blank">fbsim-core</a>, and <a href="https://crates.io/crates/fbsim-core" target="_blank">it is published on crates.io</a> as a Rust crate.&#160; I decided to publish the library as a Rust crate so that I could easily import it as a dependency in other projects which leverage the library for different purposes.&#160; For now, the only two such projects I have plans to develop are a CLI and a REST API built atop this library.&#160; These are discussed in the following sections.</p>
<p>The fbsim-core &#8203;crate &#8203;consists &#8203;of &#8203;five &#8203;source &#8203;files</p>
<ul><li role="textbox"><code target="_blank">lib.rs</code> (<a href="https://github.com/whatsacomputertho/fbsim-core/blob/main/src/lib.rs" target="_blank">src</a>): This is standard for Rust library crates.  In my case, it simply defines all of the modules exposed by the crate.<br></li><li role="textbox"><code target="_blank">boxscore.rs</code> (<a href="https://github.com/whatsacomputertho/fbsim-core/blob/main/src/boxscore.rs" target="_blank">src</a>): Contains the <code>BoxScore</code> struct implementation, which represents the final score of a football game.  Contains basic constructors and unit tests for the struct.  Most useful implementation was derived, such as the serde &amp; json schema traits.<br></li><li role="textbox"><code>gen.rs</code> (<a href="https://github.com/whatsacomputertho/fbsim-core/blob/main/src/gen.rs" target="_blank">src</a>): Contains the <code>BoxScoreGenerator</code> struct implementation, which is the core implementation of the regression models &amp; normal distribution sampler described in my football box score generator model blog.  Since the models were small, model weights were implemented as constants.  The normalized skill differentials between the home offense and away defense (and vice versa) are stored as struct properties.  The <code>gen</code> method is the main public method used to generate a box score as an <code>i32</code> tuple.<br></li><li role="textbox"><code>team.rs</code> (<a href="https://github.com/whatsacomputertho/fbsim-core/blob/main/src/team.rs" target="_blank">src</a>): Contains the <code>FootballTeam</code> struct implementation.  The team name is stored as a struct property, as are the team's offensive and defensive skill levels which are restricted to the range [0, 100].<br></li><li role="textbox"><code target="_blank">sim.rs</code> (<a href="https://github.com/whatsacomputertho/fbsim-core/blob/main/src/sim.rs" target="_blank">src</a>): Contains the <code>BoxScoreSimulator</code> struct implementation, which is a wrapper atop the <code>BoxScoreGenerator</code> struct.  This is an empty struct that exposes a single public function, <code>sim</code>, which accepts two borrowed <code>FootballTeam</code> instances (representing the home and away teams), normalizes their skill differentials, generates a final score, and then returns the final score as a <code>BoxScore</code> instance.<br></li></ul>
<p>Looking back, I do not see much of a need to split <code>BoxScoreGenerator</code> and <code>BoxScoreSimulator</code> into two separate structs - they ultimately serve the same purpose.&#160; A lot of what <code>BoxScoreGenerator</code> currently does can simply be turned into private methods with the outermost method (currently the <code>BoxScoreSimulator</code> struct's <code>sim</code> method) being the only public method.</p>
<h3 data-original-level="H3" id="header-f057d263-7b98-ea1e-e705-4bf0f40f3881">Rust &#8203;CLI</h3>
<p>CLI is an acronym that stands for command-line interface.&#160; What your command-line is&#160;depends to some degree on the OS you run.&#160; For some it may be called the terminal, for others the command prompt.&#160; But over all, you may recognize it as that bare-bones, black and white mono-spaced wall of text that programmers use.</p>
<p>A &#8203;command-line interface is just software that is written specifically to be executed through the command-line.&#160; In my case, I thought a CLI would be a useful tool to quickly execute and validate functionality from my fbsim-core crate as unit testing can only give you so much of a hint toward the stability and correctness of your software.</p>
<p>The &#8203;fbsim &#8203;CLI in its current form includes one command: <code>fbsim game sim</code>.&#160; It accepts two required arguments (paths to the home team and away team JSON files), and two optional arguments (how and where to write the simulation output).</p>
<code-sample type="json" copy-clipboard-button><template preserve-content="preserve-content"># fbsim game sim -h
The sim subcommand arguments

Usage: fbsim[.exe] game sim [OPTIONS] --home &lt;HOME&gt; --away &lt;AWAY&gt;

Options:
  -o, --output &lt;OUTPUT_FORMAT&gt;  The format to output
  -f, --file &lt;OUTPUT_FILE&gt;      The file to write to
      --home &lt;HOME&gt;             A path to a file specifying the game's home team
      --away &lt;AWAY&gt;             A path to a file specifying the game's away team
  -h, --help                    Print help</template></code-sample>
<p><a href="https://github.com/whatsacomputertho/fbsim-cli/blob/main/README.md" target="_blank">In the repository's README</a> you can find &#8203;a &#8203;short &#8203;GIF of me executing the game sim command for two example teams, and the main function is concise enough that I can copy-paste it into this blog in its current form without risking taking up too much space (though you would need to <a href="https://github.com/whatsacomputertho/fbsim-cli/tree/main/src" target="_blank">explore the source code</a> for any sort of context as to what this is doing).<br></p>
<code-sample type="javascript" copy-clipboard-button><template preserve-content="preserve-content">fn main() {
    // Parse the command-line args
    let fbsim_cli = FbsimCli::parse();

    // Perform the subcommand
    let command = fbsim_cli.command();
    match &amp;command {
        FbsimSubcommand::Game { command } =&gt; match command {
            FbsimGameSubcommand::Sim(args) =&gt; simulate_game(args.clone())
        }
    }
}</template></code-sample>
<p>Simple, short and sweet in its current form.&#160; But do not underestimate the power of command-line tools.&#160; Part of the reason I wrote this CLI was because I can envision potential future scenarios in which it may be useful to leverage in tandem with the web-based API and UI services.<br></p>
<h3 data-original-level="H3" id="header-0fd23eae-f64f-be5d-21f1-0180d7939a04">Rust API<br></h3>
<p>The acronym API&#160;in the context of computer software stands for Application Programming Interface.&#160; It is a general term that can refer to a variety of implementations which enable two software applications to "talk to each other".&#160; Prepending the acronym REST (REpresentational State Transfer) refines the scope of the term API to mean, a networked server which responds to HTTP(S) requests <a href="https://www.redhat.com/en/topics/api/what-is-a-rest-api" target="_blank">according to specific architectural guidelines</a>.</p>
<p>Across &#8203;the landscape of modern web development,&#160;REST APIs are extremely common and essential to most web-based and web-enabled applications.&#160; This is why I made the decision to develop a REST API for FBSim.&#160; From a forward-looking point of view, I knew that I would eventually develop a web-based user interface which would interact with the REST API, the REST API exposing the core application logic as an HTTP endpoint.</p>
<p>I developed a single endpoint, <code>POST /game/sim</code>, with example request &#38; response bodies given below<br></p>
<grid-plate disable-responsive layout="1-1" data-border="sm">


<p slot="col-1"><b>Example Request</b><br slot="col-2"></p><code-sample type="json" copy-clipboard-button slot="col-1"><template preserve-content="preserve-content">{
  "home": {
    "name": "string",
    "offense_overall": 0,
    "defense_overall": 0
  },
  "away": {
    "name": "string",
    "offense_overall": 0,
    "defense_overall": 0
  }
}</template></code-sample>


<p slot="col-2"><b>Example Response</b><br slot="col-3"></p><code-sample type="json" copy-clipboard-button slot="col-2"><template preserve-content="preserve-content">{
  "home_team": "string",
  "home_score": 0,
  "away_team": "string",
  "away_score": 0
}</template></code-sample>


</grid-plate>
<p>asdf</p>
<p>asdf</p>
<h3 data-original-level="H3" id="header-7f73e902-3073-9b9e-8158-852053ba8c87">Vanilla JS Web &#8203;Component UI<br></h3>
<p>Brief overview of the fbsim UI implementation</p>
<h2 data-original-level="H2" id="header-4d622995-9704-d957-3945-6ed78fe3ed7a">Deployment</h2>
<p>Brief &#8203;intro on deployment</p>
<h3 data-original-level="H3" id="header-050cd595-1eb9-410c-e040-551f7109e4a3">Docker &#8203;Compose</h3>
<p>Brief &#8203;overview &#8203;of &#8203;deploying &#8203;fbsim &#8203;using docker compose<br></p>
<h3 data-original-level="H3" id="header-e43fceb3-4c93-6ea2-b04c-11e3ee350fee">Kubernetes</h3>
<p>Brief overview of deploying fbsim on kubernetes<br></p>
